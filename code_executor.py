"""
Code Executor module - Safe execution of Python code generated by LLM.
Executes Python code in a controlled environment and captures output and errors.
"""

import os
import sys
import subprocess
import tempfile
import logging
import time
import signal
from typing import Dict, Any, Optional
from contextlib import redirect_stdout, redirect_stderr
import io

logger = logging.getLogger(__name__)

class CodeExecutor:
    """
    Safely executes Python code generated by the LLM.
    Provides isolation and captures both output and errors.
    """
    
    def __init__(self):
        # Default timeout increased to 120 s; override via env var CODE_EXECUTION_TIMEOUT
        self.timeout = int(os.getenv('CODE_EXECUTION_TIMEOUT', '120'))
        self.output_dir = 'outputs'
        self.max_output_length = int(os.getenv('MAX_OUTPUT_LENGTH', '10000'))  # 10KB default
        
        # Ensure output directory exists
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Restricted imports for security
        self.allowed_imports = {
            'pandas', 'numpy', 'matplotlib', 'seaborn', 'plotly', 'scipy',
            'sklearn', 'requests', 'json', 'csv', 're', 'datetime', 'time',
            'math', 'statistics', 'collections', 'itertools', 'functools',
            'os', 'sys', 'io', 'pathlib', 'typing'
        }
        
        # Dangerous functions to block
        self.blocked_functions = {
            'exec', 'eval', 'compile', '__import__', 'open', 'file',
            'input', 'raw_input', 'reload', 'delattr', 'setattr',
            'getattr', 'hasattr', 'globals', 'locals', 'vars', 'dir'
        }
    
    def execute_code(self, code: str, use_subprocess: bool = True) -> Dict[str, Any]:
        """
        Execute Python code and capture the results.
        
        Args:
            code: Python code to execute
            use_subprocess: Whether to use subprocess isolation (recommended)
            
        Returns:
            Dictionary with execution results
        """
        logger.info("Starting code execution")
        
        # Security check
        if not self._security_check(code):
            return {
                "success": False,
                "error": "Code contains potentially unsafe operations",
                "output": ""
            }
        
        # Clean and prepare code
        cleaned_code = self._prepare_code(code)
        
        if use_subprocess:
            return self._execute_with_subprocess(cleaned_code)
        else:
            return self._execute_inline(cleaned_code)

    def prepare_code(self, code: str) -> str:
        """Public wrapper for code preparation (used before syntax validation)."""
        return self._prepare_code(code)
    
    def _security_check(self, code: str) -> bool:
        """
        Perform basic security checks on the code.
        
        Args:
            code: Code to check
            
        Returns:
            True if code appears safe, False otherwise
        """
        # Safety checks disabled per user request
        return True
    
    def _prepare_code(self, code: str) -> str:
        """
        Clean and prepare code for execution.
        
        Args:
            code: Raw code from LLM
            
        Returns:
            Cleaned and prepared code
        """
        # Extract python code from mixed LLM output
        code = self._extract_python_code(code)
        
        # Add necessary imports if missing
        required_imports = self._detect_required_imports(code)
        import_statements = []
        
        for imp in required_imports:
            if imp not in code:
                import_statements.append(imp)
        
        if import_statements:
            code = '\n'.join(import_statements) + '\n\n' + code
        
        # Ensure output is captured
        if 'print(' not in code and 'return' not in code:
            # Add print statements for key variables
            code = self._add_output_statements(code)
        
        return code

    def _extract_python_code(self, text: str) -> str:
        """Extract Python code from an LLM response that may include prose and code fences.
        Prefers content inside the first triple-backtick block; otherwise tries to detect code heuristically.
        """
        import re
        if not text:
            return ""

        # Normalize line endings
        content = text.replace('\r\n', '\n').replace('\r', '\n')

        # Try to capture first fenced code block (```python ... ``` or ``` ... ```)
        fence_pattern = re.compile(r"```(?:python|py)?\n([\s\S]*?)```", re.IGNORECASE)
        match = fence_pattern.search(content)
        if match:
            extracted = match.group(1).strip()
            if extracted:
                return extracted

        # If no fence found, try to locate likely code start by finding first line that looks like code
        lines = content.split('\n')
        code_start = None
        code_like = re.compile(r"^(from\s+\w+\s+import|import\s+\w+|def\s+\w+\(|class\s+\w+|if\s+__name__\s*==\s*['\"]__main__['\"]:|\s*#|\s*print\(|\s*for\s+|\s*while\s+|\s*try:|\s*with\s+|\s*\w+\s*=|\s*\@\w+)")
        for idx, line in enumerate(lines):
            if code_like.search(line):
                code_start = idx
                break
        if code_start is not None:
            extracted = '\n'.join(lines[code_start:]).strip()
            return extracted

        # Fallback: return original stripped content; caller will attempt syntax validation/correction loop
        return content.strip()
    
    def _detect_required_imports(self, code: str) -> list:
        """Detect and return required import statements."""
        imports = []
        
        if 'pd.' in code or 'pandas' in code:
            imports.append('import pandas as pd')
        if 'np.' in code or 'numpy' in code:
            imports.append('import numpy as np')
        if 'plt.' in code or 'matplotlib' in code:
            imports.append('import matplotlib.pyplot as plt')
        if 'sns.' in code or 'seaborn' in code:
            imports.append('import seaborn as sns')
        if 'json.' in code:
            imports.append('import json')
        if 're.' in code:
            imports.append('import re')
        if 'datetime' in code:
            imports.append('import datetime')
        if 'requests' in code:
            imports.append('import requests')
        if 'math.' in code and 'import math' not in code:
            imports.append('import math')
        
        return imports
    
    def _add_output_statements(self, code: str) -> str:
        """Add output statements to capture results."""
        lines = code.split('\n')
        last_line = lines[-1].strip() if lines else ''
        
        # If last line is an expression (not assignment), add print
        if last_line and not any(keyword in last_line for keyword in ['=', 'print', 'return', 'if', 'for', 'while', 'def', 'class']):
            lines[-1] = f'print({last_line})'
        
        return '\n'.join(lines)
    
    def _execute_with_subprocess(self, code: str) -> Dict[str, Any]:
        """
        Execute code using subprocess for better isolation.
        
        Args:
            code: Prepared code to execute
            
        Returns:
            Execution results
        """
        # Write code to temporary file
        # Ensure output directory exists
        os.makedirs(self.output_dir, exist_ok=True)
        script_path = os.path.join(self.output_dir, f'temp_script_{int(time.time())}.py')
        
        try:
            with open(script_path, 'w', encoding='utf-8') as f:
                f.write(code)
            
            # Execute with timeout
            process = subprocess.Popen(
                [sys.executable, script_path],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                cwd=os.getcwd()  # Use current working directory instead of output_dir
            )
            
            try:
                stdout, stderr = process.communicate(timeout=self.timeout)
                return_code = process.returncode
                
                # Truncate output if too long
                if len(stdout) > self.max_output_length:
                    stdout = stdout[:self.max_output_length] + "\n... [OUTPUT TRUNCATED]"
                
                if return_code == 0:
                    return {
                        "success": True,
                        "output": stdout,
                        "error": stderr if stderr else None
                    }
                else:
                    return {
                        "success": False,
                        "error": stderr or "Unknown execution error",
                        "output": stdout
                    }
                    
            except subprocess.TimeoutExpired:
                process.kill()
                return {
                    "success": False,
                    "error": f"Code execution timed out after {self.timeout} seconds",
                    "output": ""
                }
        
        except Exception as e:
            logger.error(f"Error in subprocess execution: {str(e)}")
            return {
                "success": False,
                "error": str(e),
                "output": ""
            }
        
        finally:
            # Clean up temporary file
            if os.path.exists(script_path):
                try:
                    os.remove(script_path)
                except:
                    pass
    
    def _execute_inline(self, code: str) -> Dict[str, Any]:
        """
        Execute code inline (less secure but faster).
        
        Args:
            code: Prepared code to execute
            
        Returns:
            Execution results
        """
        stdout_buffer = io.StringIO()
        stderr_buffer = io.StringIO()
        
        try:
            # Create a restricted namespace
            namespace = {
                '__builtins__': {
                    'print': print,
                    'len': len,
                    'str': str,
                    'int': int,
                    'float': float,
                    'list': list,
                    'dict': dict,
                    'set': set,
                    'tuple': tuple,
                    'range': range,
                    'enumerate': enumerate,
                    'zip': zip,
                    'sum': sum,
                    'min': min,
                    'max': max,
                    'abs': abs,
                    'round': round,
                    'sorted': sorted,
                    'reversed': reversed
                }
            }
            
            # Redirect stdout and stderr
            with redirect_stdout(stdout_buffer), redirect_stderr(stderr_buffer):
                exec(code, namespace)
            
            output = stdout_buffer.getvalue()
            error = stderr_buffer.getvalue()
            
            # Truncate output if too long
            if len(output) > self.max_output_length:
                output = output[:self.max_output_length] + "\n... [OUTPUT TRUNCATED]"
            
            return {
                "success": True,
                "output": output,
                "error": error if error else None
            }
        
        except Exception as e:
            error = stderr_buffer.getvalue() or str(e)
            return {
                "success": False,
                "error": error,
                "output": stdout_buffer.getvalue()
            }
    
    def validate_code_syntax(self, code: str) -> Dict[str, Any]:
        """
        Validate Python code syntax without executing it.
        
        Args:
            code: Code to validate
            
        Returns:
            Dictionary with validation results
        """
        try:
            compile(code, '<string>', 'exec')
            return {
                "valid": True,
                "error": None
            }
        except SyntaxError as e:
            return {
                "valid": False,
                "error": f"Syntax error at line {e.lineno}: {e.msg}"
            }
        except Exception as e:
            return {
                "valid": False,
                "error": str(e)
            }
    
    def get_execution_stats(self) -> Dict[str, Any]:
        """
        Get execution environment statistics.
        
        Returns:
            Dictionary with environment information
        """
        return {
            "timeout": self.timeout,
            "max_output_length": self.max_output_length,
            "output_directory": self.output_dir,
            "python_version": sys.version,
            "allowed_imports": list(self.allowed_imports),
            "blocked_functions": list(self.blocked_functions)
        }